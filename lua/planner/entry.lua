local conf = require "planner.config"
local util = require "planner.util"

local TDELTA_VALS = {
	d = 24 * 60 * 60,
	w = 7 * 24 * 60 * 60,
	h = 60 * 60,
	m = 60,
	s = 1,
}

local M = {}

--- @class Entry
--- @field gcal_id string? the google calendar id for this item. It was added to a google calendar if it ~= nil
--- @field category string the category this entry fits into
--- @field raw string the unparsed data of this entry
--- @field due integer epoch time of the due date
--- @field summary string summary of event
--- @field description string? an optional description of the event
--- @field duration integer? duration of the event in seconds


--- @param list Entry[]
--- @param item Entry
--- @return Entry?
--- returns true if the list has the item (one of the list's items matches the other ite's raw field)
M.contains = function(list, item)
	for _, entry in ipairs(list) do
		if entry.raw == item.raw then
			return entry
		end
	end
	return nil
end

--- @param ent Entry
M.add_to_cal = function(ent)
	local title_case = function(str)
		local res = {}
		for _, word in ipairs(vim.split(str, " ")) do
			if #word < 1 then goto continue end
			util.append(res, string.upper(string.sub(word, 1, 1)) .. string.sub(word, 2))
			::continue::
		end
		return table.concat(res, " ")
	end
	local command = {
		conf.GCAL_BIN_PATH,
		"--credentials-file", conf.CREDENTIALS_FILE,
		"--token-file", conf.TOKEN_FILE,
		"create",
		"--summary", (ent.category and (title_case(ent.category) .. ": ") or "") .. title_case(ent.summary),
		"--description", ((ent.description ~= nil) and ("<p>" .. ent.description .. "</p>") or "") ..
	[[<p>(Automatically generated by <a href="https://github.com/benraz123/planner.nvim">planner.nvim</a>)</p>]],
		"--start-time", ent.due,
		"--time-zone", os.getenv("TZ") or "Etc/UTC"
	}

	if ent.duration ~= nil then
		util.append(command, "--end-time")
		util.append(command, ent.due + ent.duration)
	end

	local status = vim.system(command):wait()
	if status.code ~= 0 then
		vim.notify(
			string.format("failed to upload calendar event (command %s failed with code %d): %s", conf.GCAL_BIN_PATH,
				status.code, status.stderr), vim.log.levels.ERROR)
	else
		ent.gcal_id = vim.trim(status.stdout)
	end
end

--- @param ent Entry
M.remove_from_cal = function(ent)
	if ent.gcal_id == nil then return end
	local command = {
		conf.GCAL_BIN_PATH,
		"--credentials-file", conf.CREDENTIALS_FILE,
		"--token-file", conf.TOKEN_FILE,
		"delete", ent.gcal_id
	}

	vim.system(command, function(status)
		if status.code ~= 0 then
			vim.schedule(function()
				vim.notify(
					string.format("failed to delete calendar event (command %s failed with code %d): %s",
						conf.GCAL_BIN_PATH,
						status.code, status.stderr), vim.log.levels.ERROR)
			end)
		end
	end)
end


--- @param date osdate date of the entry
--- @param str string to parse
--- @return Entry
M.from_string = function(date, str)
	--- @type osdate
	local d = vim.deepcopy(date)
	local s = vim.trim(string.gsub(str, "^- ", "", 1))

	local entry = {}

	local OFFSET_REGEX = "+(%d+)([dw])"
	local offset_number, offset_type = string.match(s, OFFSET_REGEX)
	s = vim.trim(string.gsub(s, OFFSET_REGEX, "", 1))

	local HM_REGEX = "(%d+):(%d+)([apAP]?)[mM]?"
	local hour, minute, am_pm_distinguisher = string.match(s, HM_REGEX)
	s = vim.trim(string.gsub(s, HM_REGEX, "", 1))

	local offset = (offset_number or 1) * TDELTA_VALS[offset_type or "d"]
	d = util.add_delta(d, offset)
	util.hm_extend_dt(d, hour, minute, am_pm_distinguisher)

	entry.due = os.time(d)

	local CATEGORY_REGEX = ":(%w+):"
	entry.category = string.match(s, CATEGORY_REGEX)
	s = vim.trim(string.gsub(s, CATEGORY_REGEX, "", 1))

	local DESCRIPTION_REGEX = ": ?([^:]*)$"
	local descr = string.match(s, DESCRIPTION_REGEX)
	if descr ~= nil then
		entry.description = descr
		s = vim.trim(string.gsub(s, DESCRIPTION_REGEX, "", 1))
	end

	local DURATION_REGEX_1 = "(%d+)h(%d+)m"
	local duration_hours, duration_minutes = string.match(s, DURATION_REGEX_1)

	if duration_hours ~= nil and duration_minutes ~= nil then
		s = vim.trim(string.gsub(s, DURATION_REGEX_1, "", 1))
		entry.duration = tonumber(duration_minutes) * TDELTA_VALS.m + tonumber(duration_hours) * TDELTA_VALS.h
	else
		local DURATION_REGEX_2 = "(%d+)([hm])"
		local duration_multiplier, duration_type = string.match(s, DURATION_REGEX_2)
		if duration_multiplier ~= nil and duration_type ~= nil then
			entry.duration = tonumber(duration_multiplier) * TDELTA_VALS[duration_type]
			s = vim.trim(string.gsub(s, DURATION_REGEX_2, "", 1))
		end
	end

	entry.raw = str
	entry.summary = s

	return entry
end

return M
